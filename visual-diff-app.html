<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Diff - Interior Design Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .upload-box {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #fafafa;
        }

        .upload-box:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-box.has-image {
            border-color: #4caf50;
            background: #f1f8f4;
        }

        .upload-box h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .upload-box p {
            color: #666;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .upload-box input[type="file"] {
            display: none;
        }

        .upload-btn {
            background: #667eea;
            color: white;
            padding: 10px 24px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: #5568d3;
        }

        .preview-img {
            max-width: 100%;
            max-height: 200px;
            margin-top: 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .controls-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 30px;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .controls-header h2 {
            color: #333;
            font-size: 20px;
        }

        .mode-toggle {
            display: flex;
            gap: 10px;
        }

        .mode-btn {
            padding: 8px 16px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-group label {
            display: block;
            color: #333;
            font-weight: 500;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .control-row input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .control-row input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .control-row input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .control-row span {
            min-width: 50px;
            text-align: right;
            color: #667eea;
            font-weight: 600;
            font-size: 14px;
        }

        .control-row input[type="color"] {
            width: 60px;
            height: 36px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .output-section {
            margin-top: 30px;
        }

        .output-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .output-container {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            background: #f0f0f0;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .output-canvas {
            max-width: 100%;
            display: block;
            margin: 0 auto;
        }

        .status-message {
            text-align: center;
            padding: 60px 20px;
            color: #666;
            font-size: 16px;
        }

        .loading-container {
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            gap: 20px;
        }

        .loading-container.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            color: #667eea;
            font-size: 16px;
            font-weight: 500;
        }

        .loading-progress {
            color: #999;
            font-size: 14px;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 6px;
            font-size: 14px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #ddd;
        }

        .legend-gradient {
            width: 200px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #ddd;
            background: linear-gradient(to right, #0000ff, #00ffff, #00ff00, #ffff00, #ff0000);
        }

        .legend-gradient-intensity {
            width: 200px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #ddd;
            background: linear-gradient(to right, #000000, #ffffff);
        }

        .legend-labels {
            display: flex;
            justify-content: space-between;
            width: 200px;
            margin-top: 4px;
            font-size: 11px;
            color: #666;
        }

        .legend-mode {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .magnifier {
            position: fixed;
            width: 400px;
            height: 200px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            filter: drop-shadow(0 8px 24px rgba(0, 0, 0, 0.3));
        }

        .magnifier.active {
            display: block;
        }

        .magnifier-container {
            display: flex;
            background: white;
            border: 3px solid #667eea;
            border-radius: 8px;
            overflow: hidden;
        }

        .magnifier-pane {
            width: 200px;
            height: 200px;
            position: relative;
            overflow: hidden;
        }

        .magnifier-pane canvas {
            position: absolute;
            top: 0;
            left: 0;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        .magnifier-label {
            position: absolute;
            top: 5px;
            left: 5px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            z-index: 1;
        }

        .magnifier-divider {
            width: 2px;
            background: #667eea;
        }

        .magnifier-crosshair {
            position: absolute;
            width: 10px;
            height: 10px;
            border: 2px solid #fff;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.3);
            z-index: 2;
        }

        .magnifier-toggle {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #667eea;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
        }

        .magnifier-toggle:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .magnifier-toggle.active {
            background: #667eea;
            color: white;
        }

        .process-btn {
            background: #4caf50;
            color: white;
            padding: 12px 32px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
            margin-top: 20px;
        }

        .process-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.4);
        }

        .process-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            color: #1565c0;
        }

        .background-processes {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 15px;
            min-width: 250px;
            max-width: 350px;
            z-index: 10001;
            display: none;
        }

        .background-processes.active {
            display: block;
        }

        .background-processes-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .background-processes-header h3 {
            margin: 0;
            font-size: 16px;
            color: #333;
        }

        .background-processes-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .background-processes-close:hover {
            color: #333;
        }

        .process-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 14px;
        }

        .process-item-title {
            font-weight: 600;
            color: #333;
            margin-bottom: 5px;
        }

        .process-item-stage {
            color: #666;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .process-item-progress {
            width: 100%;
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
            margin-top: 5px;
        }

        .process-item-progress-bar {
            height: 100%;
            background: #667eea;
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        /* Presets and Simplified Mode Styles */
        .presets-section {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .presets-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .presets-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 12px 16px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
            text-align: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .preset-btn:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .preset-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .preset-icon {
            font-size: 24px;
        }

        .preset-name {
            font-weight: 600;
            font-size: 13px;
        }

        .preset-desc {
            font-size: 11px;
            color: #666;
            margin-top: 2px;
        }

        .preset-btn.active .preset-desc {
            color: rgba(255, 255, 255, 0.9);
        }

        .mode-switcher {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .simple-mode-toggle {
            padding: 6px 12px;
            border: 2px solid #667eea;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            color: #667eea;
        }

        .simple-mode-toggle.active {
            background: #667eea;
            color: white;
        }

        .advanced-controls {
            display: block;
        }

        .advanced-controls.hidden {
            display: none;
        }

        .simple-controls {
            display: none;
        }

        .simple-controls.visible {
            display: block;
        }

        .simple-sensitivity-label {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        /* Export Styles */
        .export-section {
            margin-top: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .export-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }

        .export-btn {
            padding: 10px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .export-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .export-btn.secondary {
            background: #6c757d;
        }

        .export-btn.secondary:hover {
            background: #5a6268;
        }

        /* Drag and Drop Styles */
        .upload-box.drag-over {
            border-color: #667eea;
            background: #e3f2fd;
            border-style: solid;
        }

        /* History Styles */
        .history-section {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 15px;
            min-width: 250px;
            max-width: 350px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 10000;
            display: none;
        }

        .history-section.active {
            display: block;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }

        .history-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .history-item:hover {
            background: #e9ecef;
        }

        .history-thumbnail {
            width: 100%;
            height: 80px;
            object-fit: cover;
            border-radius: 4px;
            margin-bottom: 5px;
        }

        .history-info {
            font-size: 12px;
            color: #666;
        }

        .history-toggle {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 6px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #667eea;
            z-index: 10001;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .history-toggle:hover {
            background: #667eea;
            color: white;
        }

        /* Projects Styles */
        .projects-section {
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .project-selector {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .project-select {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .new-project-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }

        /* Annotation Styles */
        .annotation-tools {
            margin-top: 15px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
            display: none;
        }

        .annotation-tools.active {
            display: block;
        }

        .annotation-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        .annotation-btn {
            padding: 8px 16px;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .annotation-btn:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .annotation-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .annotation-canvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 100;
        }

        .annotation-canvas.drawing {
            pointer-events: all;
        }

        .output-container {
            position: relative;
        }

        /* Presentation Mode */
        .presentation-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: #000;
            z-index: 20000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .presentation-mode.active {
            display: flex;
        }

        .presentation-content {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 40px;
        }

        .presentation-image {
            max-width: 100%;
            max-height: 80vh;
            object-fit: contain;
        }

        .presentation-stats {
            color: white;
            font-size: 24px;
            margin-top: 20px;
            text-align: center;
        }

        .presentation-controls {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 20001;
        }

        .presentation-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            backdrop-filter: blur(10px);
        }

        .presentation-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .presentation-close {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 20001;
            backdrop-filter: blur(10px);
        }

        .presentation-close:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .presets-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .export-buttons {
                flex-direction: column;
            }

            .export-btn {
                width: 100%;
            }

            .history-section {
                left: 10px;
                right: 10px;
                max-width: none;
            }

            .upload-section {
                grid-template-columns: 1fr;
            }

            .controls-section {
                padding: 15px;
            }

            .container {
                padding: 15px;
            }

            .presets-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 8px;
            }

            .preset-btn {
                padding: 10px 12px;
                font-size: 12px;
            }

            .preset-icon {
                font-size: 20px;
            }

            .history-toggle {
                top: 10px;
                left: 10px;
                padding: 6px 12px;
                font-size: 12px;
            }

            .background-processes {
                top: 10px;
                right: 10px;
                max-width: calc(100vw - 20px);
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 22px;
            }

            .presets-grid {
                grid-template-columns: 1fr;
            }

            .mode-toggle {
                flex-direction: column;
                gap: 5px;
            }

            .mode-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <button class="history-toggle" id="historyToggle">üìö History</button>
    
    <div class="history-section" id="historySection">
        <div class="history-header">
            <h3>Comparison History</h3>
            <button class="background-processes-close" id="historyClose">√ó</button>
        </div>
        <div id="historyList"></div>
    </div>

    <div class="container">
        <h1>üé® Visual Diff Tool</h1>
        <p class="subtitle">Compare before and after images with intelligent difference highlighting</p>

        <div class="projects-section" id="projectsSection">
            <div class="project-selector">
                <select id="projectSelect" class="project-select">
                    <option value="">No Project</option>
                </select>
                <button class="new-project-btn" id="newProjectBtn">+ New Project</button>
            </div>
        </div>

        <div class="presets-section">
            <div class="presets-header">
                <h3>Quick Start Presets</h3>
                <div class="mode-switcher">
                    <button class="simple-mode-toggle" id="simpleModeToggle">Simple Mode</button>
                </div>
            </div>
            <div class="presets-grid" id="presetsGrid"></div>
            <div style="text-align: center;">
                <button class="export-btn secondary" id="savePresetBtn" style="display: none;">Save Current Settings as Preset</button>
            </div>
        </div>

        <div class="info-box">
            <strong>üéØ Tips for AI-generated image comparisons:</strong><br>
            ‚Ä¢ Start with <strong>Sensitivity = 0.5-1.0</strong> to ignore AI noise and JPEG artifacts<br>
            ‚Ä¢ Use <strong>Blur = 2-5px</strong> to smooth out texture regeneration differences<br>
            ‚Ä¢ Enable <strong>Block Comparison</strong> to focus on regional color changes instead of pixel-perfect matching<br>
            ‚Ä¢ If you see 99% differences, increase sensitivity and blur until only real changes show
        </div>

        <div class="info-box" id="imageMetadata" style="display: none; background: #fff3cd; border-left-color: #ffc107;">
            <strong>üìä Image Information:</strong><br>
            <div id="metadataContent"></div>
        </div>

        <div class="upload-section">
            <div class="upload-box" id="beforeBox">
                <h3>Before Image</h3>
                <p>Click to upload the original image</p>
                <input type="file" id="beforeInput" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('beforeInput').click()">
                    Choose File
                </button>
                <img id="beforePreview" class="preview-img" style="display: none;">
            </div>

            <div class="upload-box" id="afterBox">
                <h3>After Image</h3>
                <p>Click to upload the modified image</p>
                <input type="file" id="afterInput" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('afterInput').click()">
                    Choose File
                </button>
                <img id="afterPreview" class="preview-img" style="display: none;">
            </div>
        </div>

        <div style="text-align: center; margin-top: -15px; margin-bottom: 30px;">
            <input type="file" id="bothInput" accept="image/*" multiple style="display: none;">
            <a href="#" id="bothLink" style="color: #667eea; text-decoration: none; font-size: 14px; font-weight: 500;">
                or choose both files at once
            </a>
        </div>

        <div class="controls-section">
            <div class="controls-header">
                <h2>‚öôÔ∏è Comparison Settings</h2>
                <div class="mode-toggle">
                    <button class="mode-btn active" data-mode="overlay">Overlay Mode</button>
                    <button class="mode-btn" data-mode="heatmap">Heatmap Mode</button>
                    <button class="mode-btn" data-mode="intensity">Intensity Mode</button>
                </div>
            </div>

            <div class="simple-controls" id="simpleControls">
                <div class="control-group">
                    <label class="simple-sensitivity-label">How strict should the comparison be?</label>
                    <div class="control-row">
                        <span style="font-size: 12px; color: #666;">More Forgiving</span>
                        <input type="range" id="simpleThreshold" min="0.05" max="2.0" step="0.05" value="0.5" style="flex: 1;">
                        <span style="font-size: 12px; color: #666;">More Strict</span>
                    </div>
                    <div style="text-align: center; margin-top: 5px;">
                        <span id="simpleThresholdValue" style="color: #667eea; font-weight: 600;">0.5</span>
                    </div>
                </div>
            </div>

            <div class="advanced-controls" id="advancedControls">
            <div class="control-group">
                <label>Sensitivity (higher = more forgiving, ignore subtle AI variations)</label>
                <div class="control-row">
                    <input type="range" id="threshold" min="0.05" max="2.0" step="0.05" value="0.5">
                    <span id="thresholdValue">0.5</span>
                </div>
            </div>

            <div class="control-group">
                <label>Blur Radius (smooths textures before comparing)</label>
                <div class="control-row">
                    <input type="range" id="blurRadius" min="0" max="10" step="1" value="2">
                    <span id="blurRadiusValue">2px</span>
                </div>
            </div>

            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="useFlexibleMatching">
                    <label for="useFlexibleMatching" style="margin-bottom: 0;">Enable flexible matching (perceptual similarity, SSIM-inspired)</label>
                </div>
            </div>

            <div class="control-group" id="flexibleMatchingSensitivityControl" style="display: none;">
                <label>Flexible Matching Sensitivity (higher = more forgiving)</label>
                <div class="control-row">
                    <input type="range" id="flexibleMatchingSensitivity" min="0.1" max="2.0" step="0.1" value="0.8">
                    <span id="flexibleMatchingSensitivityValue">0.8</span>
                </div>
            </div>

            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="useBlockComparison">
                    <label for="useBlockComparison" style="margin-bottom: 0;">Use block comparison (less sensitive to texture changes)</label>
                </div>
            </div>

            <div class="control-group" id="blockSizeControl" style="display: none;">
                <label>Block Size</label>
                <div class="control-row">
                    <input type="range" id="blockSize" min="4" max="32" step="4" value="16">
                    <span id="blockSizeValue">16px</span>
                </div>
            </div>

            <div class="control-group">
                <label>Overlay Opacity</label>
                <div class="control-row">
                    <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="0.5">
                    <span id="opacityValue">0.5</span>
                </div>
            </div>

            <div class="control-group">
                <label>Change Highlight Color</label>
                <div class="control-row">
                    <input type="color" id="highlightColor" value="#ff6b6b">
                    <span>Red = Changed</span>
                </div>
            </div>

            <div class="control-group">
                <label>Minimum Change Region Size (pixels)</label>
                <div class="control-row">
                    <input type="range" id="minRegionSize" min="1" max="100" step="1" value="10">
                    <span id="minRegionSizeValue">10</span>
                </div>
            </div>

            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="showOutlines" checked>
                    <label for="showOutlines" style="margin-bottom: 0;">Draw outlines around changed regions</label>
                </div>
            </div>

            <div class="control-group">
                <div class="checkbox-group">
                    <input type="checkbox" id="autoAlign">
                    <label for="autoAlign" style="margin-bottom: 0;">Auto-align images (detect and correct crop/position differences)</label>
                </div>
            </div>

            <div class="control-group" id="manualAlignmentControl" style="display: none;">
                <label>Manual Alignment (X, Y offset in pixels)</label>
                <div class="control-row">
                    <label style="min-width: 30px; margin: 0;">X:</label>
                    <input type="range" id="alignX" min="-100" max="100" step="1" value="0">
                    <span id="alignXValue" style="min-width: 50px;">0</span>
                </div>
                <div class="control-row" style="margin-top: 10px;">
                    <label style="min-width: 30px; margin: 0;">Y:</label>
                    <input type="range" id="alignY" min="-100" max="100" step="1" value="0">
                    <span id="alignYValue" style="min-width: 50px;">0</span>
                </div>
            </div>

            </div>

            <button class="process-btn" id="processBtn" disabled>
                Generate Comparison
            </button>
        </div>

        <div class="background-processes" id="backgroundProcesses">
            <div class="background-processes-header">
                <h3>üîÑ Background Processing</h3>
                <button class="background-processes-close" id="backgroundProcessesClose">√ó</button>
            </div>
            <div id="processItems"></div>
        </div>

        <div class="output-section">
            <h2>üìä Comparison Result</h2>
            <div class="output-container" id="outputContainer">
                <canvas id="outputCanvas" class="output-canvas"></canvas>
                <canvas id="annotationCanvas" class="annotation-canvas"></canvas>
                <div id="statusMessage" class="status-message">
                    Upload both images to begin
                </div>
                <div id="loadingContainer" class="loading-container">
                    <div class="spinner"></div>
                    <div class="loading-text">Processing images...</div>
                    <div class="loading-progress" id="loadingProgress">Analyzing differences</div>
                </div>
                <button class="magnifier-toggle" id="magnifierToggle" style="display: none;">
                    üîç Enable Magnifier
                </button>
            </div>
            <div class="magnifier" id="magnifier">
                <div class="magnifier-container">
                    <div class="magnifier-pane">
                        <div class="magnifier-label">Before</div>
                        <canvas id="magnifierBefore"></canvas>
                        <div class="magnifier-crosshair"></div>
                    </div>
                    <div class="magnifier-divider"></div>
                    <div class="magnifier-pane">
                        <div class="magnifier-label">After</div>
                        <canvas id="magnifierAfter"></canvas>
                        <div class="magnifier-crosshair"></div>
                    </div>
                </div>
            </div>
            <div class="legend" id="legend" style="display: none;">
                <!-- Overlay mode legend -->
                <div class="legend-mode" id="legendOverlay">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff6b6b;"></div>
                        <span>Changed Areas</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(0,0,0,0); border: 2px solid #ddd;"></div>
                        <span>Unchanged Areas</span>
                    </div>
                </div>
                
                <!-- Heatmap mode legend -->
                <div class="legend-mode" id="legendHeatmap" style="display: none;">
                    <div class="legend-item" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                        <div class="legend-gradient"></div>
                        <div class="legend-labels">
                            <span>Low</span>
                            <span>High</span>
                        </div>
                        <span style="font-size: 12px; color: #666;">Difference Intensity</span>
                    </div>
                </div>
                
                <!-- Intensity mode legend -->
                <div class="legend-mode" id="legendIntensity" style="display: none;">
                    <div class="legend-item" style="flex-direction: column; align-items: flex-start; gap: 4px;">
                        <div class="legend-gradient-intensity"></div>
                        <div class="legend-labels">
                            <span>No Change</span>
                            <span>Max Change</span>
                        </div>
                        <span style="font-size: 12px; color: #666;">Difference Magnitude</span>
                    </div>
                </div>
                
                <!-- Stats (shown for all modes) -->
                <div class="legend-item" style="margin-left: auto;">
                    <span id="statsText"></span>
                </div>
            </div>

            <div class="annotation-tools" id="annotationTools">
                <h3>Annotation Tools</h3>
                <div class="annotation-buttons">
                    <button class="annotation-btn" id="drawBtn" data-tool="draw">‚úèÔ∏è Draw</button>
                    <button class="annotation-btn" id="arrowBtn" data-tool="arrow">‚û°Ô∏è Arrow</button>
                    <button class="annotation-btn" id="textBtn" data-tool="text">üìù Text</button>
                    <button class="annotation-btn" id="highlightBtn" data-tool="highlight">üñçÔ∏è Highlight</button>
                    <button class="annotation-btn" id="clearAnnotationsBtn">üóëÔ∏è Clear</button>
                </div>
                <p style="font-size: 12px; color: #666; margin-top: 10px;">
                    Click and drag on the comparison to annotate. Use Clear to remove all annotations.
                </p>
            </div>

            <div class="export-section" id="exportSection" style="display: none;">
                <h3>Export Comparison</h3>
                <div class="export-buttons">
                    <button class="export-btn" id="exportPNG">Download PNG</button>
                    <button class="export-btn" id="exportJPEG">Download JPEG</button>
                    <button class="export-btn" id="exportSideBySide">Side-by-Side</button>
                    <button class="export-btn" id="exportPDF">PDF Report</button>
                    <button class="export-btn secondary" id="copyToClipboard">Copy to Clipboard</button>
                    <button class="export-btn secondary" id="toggleAnnotationsBtn">Toggle Annotations</button>
                    <button class="export-btn" id="presentationModeBtn">üì∫ Presentation Mode</button>
                </div>
            </div>
        </div>
    </div>

    <div class="presentation-mode" id="presentationMode">
        <div class="presentation-content" id="presentationContent">
            <img id="presentationImage" class="presentation-image" alt="Comparison">
            <div class="presentation-stats" id="presentationStats"></div>
        </div>
        <div class="presentation-controls">
            <button class="presentation-btn" id="presentationPrev">‚óÄ Previous</button>
            <button class="presentation-btn" id="presentationNext">Next ‚ñ∂</button>
        </div>
        <button class="presentation-close" id="presentationClose">√ó</button>
    </div>

    <script src="presets.js"></script>

    <script>
        // Web Worker for image processing
        let imageWorker = null;
        let currentProcessId = null;
        let processQueue = [];

        function initWorker() {
            if (!imageWorker) {
                imageWorker = new Worker('image-processor-worker.js');
                
                imageWorker.addEventListener('message', function(e) {
                    const { type, progress, stage, diff, numDiffPixels, diffArray, error } = e.data;
                    
                    if (type === 'progress') {
                        updateProcessProgress(currentProcessId, progress, stage);
                    } else if (type === 'result') {
                        handleWorkerResult(diff, numDiffPixels, diffArray);
                    } else if (type === 'error') {
                        console.error('Worker error:', error);
                        handleWorkerError(error);
                    }
                });
                
                imageWorker.addEventListener('error', function(e) {
                    console.error('Worker error:', e);
                    handleWorkerError(e.message);
                });
            }
        }

        const stageNames = {
            'blur-before': 'Blurring before image...',
            'blur-after': 'Blurring after image...',
            'blur': 'Applying blur...',
            'pixel-comparison': 'Comparing pixels...',
            'block-comparison': 'Comparing blocks...',
            'morphology': 'Processing regions...'
        };

        function updateProcessProgress(processId, progress, stage) {
            const processItems = document.getElementById('processItems');
            const processItem = document.getElementById(`process-${processId}`);
            
            if (processItem) {
                const progressBar = processItem.querySelector('.process-item-progress-bar');
                const stageText = processItem.querySelector('.process-item-stage');
                
                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                }
                if (stageText) {
                    stageText.textContent = stageNames[stage] || stage;
                }
            }
            
            // Update main loading progress
            const loadingProgress = document.getElementById('loadingProgress');
            if (loadingProgress) {
                loadingProgress.textContent = stageNames[stage] || 'Processing...';
            }
        }

        function addProcessToQueue(processId, title) {
            const backgroundProcesses = document.getElementById('backgroundProcesses');
            const processItems = document.getElementById('processItems');
            
            const processItem = document.createElement('div');
            processItem.className = 'process-item';
            processItem.id = `process-${processId}`;
            processItem.innerHTML = `
                <div class="process-item-title">${title}</div>
                <div class="process-item-stage">Initializing...</div>
                <div class="process-item-progress">
                    <div class="process-item-progress-bar" style="width: 0%"></div>
                </div>
            `;
            
            processItems.appendChild(processItem);
            backgroundProcesses.classList.add('active');
        }

        function removeProcessFromQueue(processId) {
            const processItem = document.getElementById(`process-${processId}`);
            if (processItem) {
                processItem.remove();
            }
            
            const processItems = document.getElementById('processItems');
            if (processItems.children.length === 0) {
                const backgroundProcesses = document.getElementById('backgroundProcesses');
                backgroundProcesses.classList.remove('active');
            }
        }

        function handleWorkerResult(diff, numDiffPixels, diffArray) {
            const diffArrayTyped = new Uint8Array(diff);
            const originalDiffArray = new Uint8Array(diffArray);
            
            // Continue with rendering (this part stays on main thread)
            renderComparisonResult(diffArrayTyped, originalDiffArray, numDiffPixels);
            
            // Remove process from queue
            if (currentProcessId) {
                setTimeout(() => {
                    removeProcessFromQueue(currentProcessId);
                }, 500);
            }
        }

        function handleWorkerError(error) {
            const statusMessage = document.getElementById('statusMessage');
            const loadingContainer = document.getElementById('loadingContainer');
            const processBtn = document.getElementById('processBtn');
            
            statusMessage.textContent = `Error processing images: ${error}`;
            statusMessage.style.display = 'block';
            loadingContainer.classList.remove('active');
            processBtn.disabled = false;
            processBtn.textContent = 'Generate Comparison';
            
            if (currentProcessId) {
                removeProcessFromQueue(currentProcessId);
            }
        }

        // Background processes UI
        document.getElementById('backgroundProcessesClose').addEventListener('click', () => {
            const backgroundProcesses = document.getElementById('backgroundProcesses');
            backgroundProcesses.classList.remove('active');
        });

        let beforeImage = null;
        let afterImage = null;
        let currentMode = 'overlay';
        let magnifierEnabled = false;
        let beforeCanvasData = null;
        let afterCanvasData = null;
        let alignmentOffset = { x: 0, y: 0 };

        // Image upload handlers
        document.getElementById('beforeInput').addEventListener('change', (e) => {
            handleImageUpload(e, 'before');
        });

        document.getElementById('afterInput').addEventListener('change', (e) => {
            handleImageUpload(e, 'after');
        });

        // Both files at once handler
        document.getElementById('bothLink').addEventListener('click', (e) => {
            e.preventDefault();
            document.getElementById('bothInput').click();
        });

        document.getElementById('bothInput').addEventListener('change', (e) => {
            const files = e.target.files;
            
            if (files.length === 0) {
                return;
            }
            
            if (files.length === 1) {
                alert('Please select 2 images. First will be "Before", second will be "After".');
                return;
            }
            
            if (files.length > 2) {
                console.log(`User selected ${files.length} files. Using first 2, ignoring the rest.`);
            }
            
            // Load first file as "before"
            loadFileAsImage(files[0], 'before');
            
            // Load second file as "after"
            loadFileAsImage(files[1], 'after');
            
            // Clear the input so the same files can be selected again if needed
            e.target.value = '';
        });

        function loadFileAsImage(file, type) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    if (type === 'before') {
                        beforeImage = img;
                        beforeImage.fileType = file.type;
                        beforeImage.fileName = file.name;
                        beforeImage.fileSize = file.size;
                        document.getElementById('beforePreview').src = e.target.result;
                        document.getElementById('beforePreview').style.display = 'block';
                        document.getElementById('beforeBox').classList.add('has-image');
                    } else {
                        afterImage = img;
                        afterImage.fileType = file.type;
                        afterImage.fileName = file.name;
                        afterImage.fileSize = file.size;
                        document.getElementById('afterPreview').src = e.target.result;
                        document.getElementById('afterPreview').style.display = 'block';
                        document.getElementById('afterBox').classList.add('has-image');
                    }
                    checkIfReadyToProcess();
                    updateImageMetadata();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function handleImageUpload(event, type) {
            const file = event.target.files[0];
            if (!file) return;
            loadFileAsImage(file, type);
        }

        function updateImageMetadata() {
            if (!beforeImage || !afterImage) return;

            const metadataBox = document.getElementById('imageMetadata');
            const metadataContent = document.getElementById('metadataContent');
            
            const beforeFormat = beforeImage.fileType || 'unknown';
            const afterFormat = afterImage.fileType || 'unknown';
            const beforeSize = (beforeImage.fileSize / 1024).toFixed(1);
            const afterSize = (afterImage.fileSize / 1024).toFixed(1);
            
            const formatMismatch = beforeFormat !== afterFormat;
            const sizeMismatch = beforeImage.width !== afterImage.width || beforeImage.height !== afterImage.height;
            
            let warnings = [];
            if (formatMismatch) {
                warnings.push(`‚ö†Ô∏è Different formats (${beforeFormat} vs ${afterFormat}) - may cause compression artifacts`);
            }
            if (beforeFormat.includes('jpeg') || afterFormat.includes('jpeg') || 
                beforeFormat.includes('webp') || afterFormat.includes('webp')) {
                warnings.push(`‚ö†Ô∏è Lossy compression detected - expect high difference rates even for similar images`);
            }
            if (sizeMismatch) {
                warnings.push(`‚ö†Ô∏è Different dimensions - before will be resized to match after`);
            }
            
            let html = `
                <strong>Before:</strong> ${beforeImage.fileName} (${beforeImage.width}√ó${beforeImage.height}, ${beforeFormat}, ${beforeSize}KB)<br>
                <strong>After:</strong> ${afterImage.fileName} (${afterImage.width}√ó${afterImage.height}, ${afterFormat}, ${afterSize}KB)
            `;
            
            if (warnings.length > 0) {
                html += '<br><br>' + warnings.join('<br>');
                html += '<br><br><strong>üí° Recommendation:</strong> Increase Sensitivity to 0.8+ and enable Blur (3-5px) to compensate for compression differences';
            }
            
            metadataContent.innerHTML = html;
            metadataBox.style.display = 'block';
        }

        function checkIfReadyToProcess() {
            const processBtn = document.getElementById('processBtn');
            if (beforeImage && afterImage) {
                processBtn.disabled = false;
            }
        }

        // Control value updates
        document.getElementById('threshold').addEventListener('input', (e) => {
            document.getElementById('thresholdValue').textContent = e.target.value;
        });

        document.getElementById('opacity').addEventListener('input', (e) => {
            document.getElementById('opacityValue').textContent = e.target.value;
        });

        document.getElementById('minRegionSize').addEventListener('input', (e) => {
            document.getElementById('minRegionSizeValue').textContent = e.target.value;
        });

        document.getElementById('blurRadius').addEventListener('input', (e) => {
            document.getElementById('blurRadiusValue').textContent = e.target.value + 'px';
        });

        document.getElementById('blockSize').addEventListener('input', (e) => {
            document.getElementById('blockSizeValue').textContent = e.target.value + 'px';
        });

        document.getElementById('useBlockComparison').addEventListener('change', (e) => {
            document.getElementById('blockSizeControl').style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('flexibleMatchingSensitivity').addEventListener('input', (e) => {
            document.getElementById('flexibleMatchingSensitivityValue').textContent = e.target.value;
        });

        document.getElementById('useFlexibleMatching').addEventListener('change', (e) => {
            document.getElementById('flexibleMatchingSensitivityControl').style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('alignX').addEventListener('input', (e) => {
            document.getElementById('alignXValue').textContent = e.target.value;
        });

        document.getElementById('alignY').addEventListener('input', (e) => {
            document.getElementById('alignYValue').textContent = e.target.value;
        });

        document.getElementById('autoAlign').addEventListener('change', (e) => {
            const manualControl = document.getElementById('manualAlignmentControl');
            if (e.target.checked) {
                manualControl.style.display = 'block';
            } else {
                manualControl.style.display = 'none';
            }
        });

        // Update legend color when highlight color changes
        document.getElementById('highlightColor').addEventListener('input', (e) => {
            const overlayColorBox = document.querySelector('#legendOverlay .legend-color');
            if (overlayColorBox) {
                overlayColorBox.style.background = e.target.value;
            }
        });

        // Mode toggle
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                currentMode = e.target.dataset.mode;
                updateLegendForMode();
            });
        });

        // Update legend based on current mode
        function updateLegendForMode() {
            const legendOverlay = document.getElementById('legendOverlay');
            const legendHeatmap = document.getElementById('legendHeatmap');
            const legendIntensity = document.getElementById('legendIntensity');
            
            // Hide all legend modes
            legendOverlay.style.display = 'none';
            legendHeatmap.style.display = 'none';
            legendIntensity.style.display = 'none';
            
            // Show appropriate legend for current mode
            if (currentMode === 'overlay') {
                legendOverlay.style.display = 'flex';
            } else if (currentMode === 'heatmap') {
                legendHeatmap.style.display = 'flex';
            } else if (currentMode === 'intensity') {
                legendIntensity.style.display = 'flex';
            }
        }

        // Magnifier toggle
        document.getElementById('magnifierToggle').addEventListener('click', (e) => {
            magnifierEnabled = !magnifierEnabled;
            const magnifier = document.getElementById('magnifier');
            const toggle = document.getElementById('magnifierToggle');
            
            if (magnifierEnabled) {
                toggle.classList.add('active');
                toggle.textContent = 'üîç Disable Magnifier';
            } else {
                toggle.classList.remove('active');
                toggle.textContent = 'üîç Enable Magnifier';
                magnifier.classList.remove('active');
            }
        });

        // Setup magnifier mouse tracking
        function setupMagnifier() {
            const outputContainer = document.getElementById('outputContainer');
            const canvas = document.getElementById('outputCanvas');
            const magnifier = document.getElementById('magnifier');
            const magnifierBefore = document.getElementById('magnifierBefore');
            const magnifierAfter = document.getElementById('magnifierAfter');
            
            // Set magnifier canvas sizes (200x200 at 2x zoom = 100x100 source area)
            magnifierBefore.width = 200;
            magnifierBefore.height = 200;
            magnifierAfter.width = 200;
            magnifierAfter.height = 200;
            
            outputContainer.addEventListener('mousemove', (e) => {
                if (!magnifierEnabled || !beforeCanvasData || !afterCanvasData) return;
                
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                // Get mouse position relative to canvas
                const mouseX = (e.clientX - rect.left) * scaleX;
                const mouseY = (e.clientY - rect.top) * scaleY;
                
                // Check if mouse is within canvas bounds
                if (mouseX < 0 || mouseX > canvas.width || mouseY < 0 || mouseY > canvas.height) {
                    magnifier.classList.remove('active');
                    return;
                }
                
                // Show magnifier
                magnifier.classList.add('active');
                
                // Position magnifier 20px above cursor, centered
                const magnifierX = e.clientX - 200; // Center the 400px width
                const magnifierY = e.clientY - 220; // 20px above cursor
                
                // Keep magnifier on screen
                const clampedX = Math.max(10, Math.min(magnifierX, window.innerWidth - 410));
                const clampedY = Math.max(10, magnifierY);
                
                magnifier.style.left = clampedX + 'px';
                magnifier.style.top = clampedY + 'px';
                
                // Draw magnified areas (100x100 source area, scaled to 200x200)
                const ctxBefore = magnifierBefore.getContext('2d');
                const ctxAfter = magnifierAfter.getContext('2d');
                
                // Clear canvases
                ctxBefore.clearRect(0, 0, 200, 200);
                ctxAfter.clearRect(0, 0, 200, 200);
                
                // Calculate source area (100x100 centered on cursor)
                const sourceSize = 100;
                const halfSize = sourceSize / 2;
                let sourceX = Math.floor(mouseX - halfSize);
                let sourceY = Math.floor(mouseY - halfSize);
                
                // Clamp source coordinates
                sourceX = Math.max(0, Math.min(sourceX, canvas.width - sourceSize));
                sourceY = Math.max(0, Math.min(sourceY, canvas.height - sourceSize));
                
                // Draw magnified sections (2x zoom)
                ctxBefore.imageSmoothingEnabled = false;
                ctxAfter.imageSmoothingEnabled = false;
                
                ctxBefore.drawImage(
                    beforeCanvasData,
                    sourceX, sourceY, sourceSize, sourceSize,
                    0, 0, 200, 200
                );
                
                ctxAfter.drawImage(
                    afterCanvasData,
                    sourceX, sourceY, sourceSize, sourceSize,
                    0, 0, 200, 200
                );
            });
            
            outputContainer.addEventListener('mouseleave', () => {
                magnifier.classList.remove('active');
            });
        }

        // Process button
        document.getElementById('processBtn').addEventListener('click', () => {
            // Show loading state
            const canvas = document.getElementById('outputCanvas');
            const statusMessage = document.getElementById('statusMessage');
            const loadingContainer = document.getElementById('loadingContainer');
            const legend = document.getElementById('legend');
            const processBtn = document.getElementById('processBtn');
            
            // Hide canvas and status, show loading
            canvas.style.display = 'none';
            statusMessage.style.display = 'none';
            legend.style.display = 'none';
            loadingContainer.classList.add('active');
            
            // Update legend color for overlay mode if highlight color changed
            const highlightColor = document.getElementById('highlightColor').value;
            const overlayColorBox = document.querySelector('#legendOverlay .legend-color');
            if (overlayColorBox) {
                overlayColorBox.style.background = highlightColor;
            }
            processBtn.disabled = true;
            processBtn.textContent = 'Processing...';
            
            // Use setTimeout to allow UI to update before heavy processing
            setTimeout(() => {
                try {
                    processImages();
                    
                    // Store canvas data for magnifier
                    const tempBeforeCanvas = document.createElement('canvas');
                    const tempAfterCanvas = document.createElement('canvas');
                    tempBeforeCanvas.width = afterImage.width;
                    tempBeforeCanvas.height = afterImage.height;
                    tempAfterCanvas.width = afterImage.width;
                    tempAfterCanvas.height = afterImage.height;
                    
                    const tempBeforeCtx = tempBeforeCanvas.getContext('2d');
                    const tempAfterCtx = tempAfterCanvas.getContext('2d');
                    
                    tempBeforeCtx.drawImage(beforeImage, 0, 0, afterImage.width, afterImage.height);
                    tempAfterCtx.drawImage(afterImage, 0, 0);
                    
                    beforeCanvasData = tempBeforeCanvas;
                    afterCanvasData = tempAfterCanvas;
                    
                    // Show results
                    canvas.style.display = 'block';
                    loadingContainer.classList.remove('active');
                    legend.style.display = 'flex';
                    
                    // Show magnifier toggle button
                    document.getElementById('magnifierToggle').style.display = 'block';
                } catch (error) {
                    console.error('Error processing images:', error);
                    statusMessage.textContent = 'Error processing images. Please try again.';
                    statusMessage.style.display = 'block';
                    loadingContainer.classList.remove('active');
                } finally {
                    processBtn.disabled = false;
                    processBtn.textContent = 'Generate Comparison';
                }
            }, 50);
        });

        // Image alignment using template matching
        function findAlignmentOffset(img1Data, img2Data, width, height) {
            const searchRange = 50; // Search ¬±50 pixels
            const templateSize = Math.min(200, Math.floor(Math.min(width, height) * 0.2)); // 20% of image or 200px
            
            // Use center region as template
            const templateX = Math.floor((width - templateSize) / 2);
            const templateY = Math.floor((height - templateSize) / 2);
            
            let bestOffset = { x: 0, y: 0 };
            let bestScore = Infinity;
            
            // Extract template from img1 (before image)
            const template = new Uint8ClampedArray(templateSize * templateSize * 4);
            for (let y = 0; y < templateSize; y++) {
                for (let x = 0; x < templateSize; x++) {
                    const srcIdx = ((templateY + y) * width + (templateX + x)) * 4;
                    const dstIdx = (y * templateSize + x) * 4;
                    template[dstIdx] = img1Data[srcIdx];
                    template[dstIdx + 1] = img1Data[srcIdx + 1];
                    template[dstIdx + 2] = img1Data[srcIdx + 2];
                    template[dstIdx + 3] = img1Data[srcIdx + 3];
                }
            }
            
            // Search for best match in img2 (after image)
            for (let dy = -searchRange; dy <= searchRange; dy += 2) { // Step by 2 for performance
                for (let dx = -searchRange; dx <= searchRange; dx += 2) {
                    const searchX = templateX + dx;
                    const searchY = templateY + dy;
                    
                    // Check bounds
                    if (searchX < 0 || searchY < 0 || 
                        searchX + templateSize >= width || 
                        searchY + templateSize >= height) {
                        continue;
                    }
                    
                    // Calculate sum of squared differences
                    let ssd = 0;
                    for (let y = 0; y < templateSize; y++) {
                        for (let x = 0; x < templateSize; x++) {
                            const templateIdx = (y * templateSize + x) * 4;
                            const searchIdx = ((searchY + y) * width + (searchX + x)) * 4;
                            
                            const dr = template[templateIdx] - img2Data[searchIdx];
                            const dg = template[templateIdx + 1] - img2Data[searchIdx + 1];
                            const db = template[templateIdx + 2] - img2Data[searchIdx + 2];
                            
                            ssd += dr * dr + dg * dg + db * db;
                        }
                    }
                    
                    if (ssd < bestScore) {
                        bestScore = ssd;
                        bestOffset = { x: dx, y: dy };
                    }
                }
            }
            
            return bestOffset;
        }

        function applyAlignment(ctx, image, offsetX, offsetY, targetWidth, targetHeight) {
            ctx.clearRect(0, 0, targetWidth, targetHeight);
            ctx.drawImage(image, offsetX, offsetY, targetWidth, targetHeight);
        }

        function processImages() {
            if (!beforeImage || !afterImage) return;

            // Initialize worker
            initWorker();

            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size to match after image
            canvas.width = afterImage.width;
            canvas.height = afterImage.height;

            // Create temporary canvases for before and after
            const beforeCanvas = document.createElement('canvas');
            const afterCanvas = document.createElement('canvas');
            beforeCanvas.width = afterImage.width;
            beforeCanvas.height = afterImage.height;
            afterCanvas.width = afterImage.width;
            afterCanvas.height = afterImage.height;

            const beforeCtx = beforeCanvas.getContext('2d');
            const afterCtx = afterCanvas.getContext('2d');

            // Draw images (resize before image if needed)
            beforeCtx.drawImage(beforeImage, 0, 0, afterImage.width, afterImage.height);
            afterCtx.drawImage(afterImage, 0, 0);

            // Handle alignment
            const autoAlign = document.getElementById('autoAlign').checked;
            const manualAlignX = parseInt(document.getElementById('alignX').value);
            const manualAlignY = parseInt(document.getElementById('alignY').value);
            
            if (autoAlign || manualAlignX !== 0 || manualAlignY !== 0) {
                let offsetX = manualAlignX;
                let offsetY = manualAlignY;
                
                if (autoAlign) {
                    // Perform automatic alignment
                    const beforeData = beforeCtx.getImageData(0, 0, afterImage.width, afterImage.height);
                    const afterData = afterCtx.getImageData(0, 0, afterImage.width, afterImage.height);
                    
                    const autoOffset = findAlignmentOffset(
                        beforeData.data,
                        afterData.data,
                        afterImage.width,
                        afterImage.height
                    );
                    
                    offsetX = autoOffset.x;
                    offsetY = autoOffset.y;
                    alignmentOffset = { x: offsetX, y: offsetY };
                    
                    // Update manual controls to show detected offset
                    document.getElementById('alignX').value = offsetX;
                    document.getElementById('alignXValue').textContent = offsetX;
                    document.getElementById('alignY').value = offsetY;
                    document.getElementById('alignYValue').textContent = offsetY;
                } else {
                    alignmentOffset = { x: offsetX, y: offsetY };
                }
                
                // Apply alignment to before image
                beforeCtx.clearRect(0, 0, afterImage.width, afterImage.height);
                beforeCtx.drawImage(beforeImage, offsetX, offsetY, afterImage.width, afterImage.height);
            } else {
                alignmentOffset = { x: 0, y: 0 };
            }

            // Get image data
            const beforeData = beforeCtx.getImageData(0, 0, afterImage.width, afterImage.height);
            const afterData = afterCtx.getImageData(0, 0, afterImage.width, afterImage.height);

            // Get settings
            const threshold = parseFloat(document.getElementById('threshold').value);
            const blurRadius = parseInt(document.getElementById('blurRadius').value);
            const useBlockComparison = document.getElementById('useBlockComparison').checked;
            const blockSize = parseInt(document.getElementById('blockSize').value);
            const minRegionSize = parseInt(document.getElementById('minRegionSize').value);
            const useFlexibleMatching = document.getElementById('useFlexibleMatching').checked;
            const flexibleSensitivity = parseFloat(document.getElementById('flexibleMatchingSensitivity').value);

            // Generate process ID
            currentProcessId = 'process-' + Date.now();
            addProcessToQueue(currentProcessId, 'Image Comparison');

            // Send data to worker
            imageWorker.postMessage({
                type: 'process',
                data: {
                    beforeData: beforeData.data.buffer,
                    afterData: afterData.data.buffer,
                    width: afterImage.width,
                    height: afterImage.height,
                    threshold: threshold,
                    blurRadius: blurRadius,
                    useBlockComparison: useBlockComparison,
                    blockSize: blockSize,
                    minRegionSize: minRegionSize,
                    useFlexibleMatching: useFlexibleMatching,
                    flexibleSensitivity: flexibleSensitivity
                }
            }, [beforeData.data.buffer, afterData.data.buffer]);
        }

        function renderComparisonResult(processed, originalDiff, numDiffPixels) {
            const canvas = document.getElementById('outputCanvas');
            const ctx = canvas.getContext('2d');
            
            // Get settings for rendering
            const opacity = parseFloat(document.getElementById('opacity').value);
            const highlightColor = hexToRgb(document.getElementById('highlightColor').value);
            const showOutlines = document.getElementById('showOutlines').checked;

            // Calculate percentage of change
            const totalPixels = canvas.width * canvas.height;
            const changePercent = ((numDiffPixels / totalPixels) * 100).toFixed(2);

            if (currentMode === 'overlay') {
                // Overlay mode: show after image with highlighted differences
                ctx.drawImage(afterImage, 0, 0);

                // Create overlay
                const overlayData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                for (let i = 0; i < processed.length; i++) {
                    if (processed[i] > 0) {
                        const pixelIndex = i * 4;
                        // Blend highlight color with original
                        overlayData.data[pixelIndex] = Math.floor(
                            overlayData.data[pixelIndex] * (1 - opacity) + highlightColor.r * opacity
                        );
                        overlayData.data[pixelIndex + 1] = Math.floor(
                            overlayData.data[pixelIndex + 1] * (1 - opacity) + highlightColor.g * opacity
                        );
                        overlayData.data[pixelIndex + 2] = Math.floor(
                            overlayData.data[pixelIndex + 2] * (1 - opacity) + highlightColor.b * opacity
                        );
                    }
                }

                ctx.putImageData(overlayData, 0, 0);

                // Draw outlines if enabled
                if (showOutlines) {
                    drawOutlines(ctx, processed, canvas.width, canvas.height);
                }
            } else if (currentMode === 'heatmap') {
                // Heatmap mode: show difference intensity with gradient
                ctx.drawImage(afterImage, 0, 0);
                
                const heatmapData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Find max intensity for normalization
                let maxIntensity = 0;
                for (let i = 0; i < originalDiff.length; i++) {
                    if (originalDiff[i] > maxIntensity) {
                        maxIntensity = originalDiff[i];
                    }
                }
                
                for (let i = 0; i < originalDiff.length; i++) {
                    if (originalDiff[i] > 0) {
                        const pixelIndex = i * 4;
                        // Use actual magnitude from diff array (0-255)
                        const normalizedIntensity = maxIntensity > 0 ? (originalDiff[i] / maxIntensity) * 255 : originalDiff[i];
                        const heatColor = intensityToHeatColor(normalizedIntensity);
                        
                        // Blend with original
                        heatmapData.data[pixelIndex] = Math.floor(
                            heatmapData.data[pixelIndex] * (1 - opacity) + heatColor.r * opacity
                        );
                        heatmapData.data[pixelIndex + 1] = Math.floor(
                            heatmapData.data[pixelIndex + 1] * (1 - opacity) + heatColor.g * opacity
                        );
                        heatmapData.data[pixelIndex + 2] = Math.floor(
                            heatmapData.data[pixelIndex + 2] * (1 - opacity) + heatColor.b * opacity
                        );
                    }
                }
                
                ctx.putImageData(heatmapData, 0, 0);
            } else if (currentMode === 'intensity') {
                // Intensity mode: show raw difference magnitude
                ctx.drawImage(afterImage, 0, 0);
                
                const intensityData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Find max intensity for normalization
                let maxIntensity = 0;
                for (let i = 0; i < originalDiff.length; i++) {
                    if (originalDiff[i] > maxIntensity) {
                        maxIntensity = originalDiff[i];
                    }
                }
                
                for (let i = 0; i < originalDiff.length; i++) {
                    const pixelIndex = i * 4;
                    // Map magnitude directly to grayscale
                    const intensity = maxIntensity > 0 ? (originalDiff[i] / maxIntensity) * 255 : 0;
                    
                    // Blend intensity with original (grayscale overlay)
                    const gray = Math.floor(intensity);
                    intensityData.data[pixelIndex] = Math.floor(
                        intensityData.data[pixelIndex] * (1 - opacity) + gray * opacity
                    );
                    intensityData.data[pixelIndex + 1] = Math.floor(
                        intensityData.data[pixelIndex + 1] * (1 - opacity) + gray * opacity
                    );
                    intensityData.data[pixelIndex + 2] = Math.floor(
                        intensityData.data[pixelIndex + 2] * (1 - opacity) + gray * opacity
                    );
                }
                
                ctx.putImageData(intensityData, 0, 0);
            }

            // Update UI
            document.getElementById('statsText').textContent = 
                `${changePercent}% of image changed (${numDiffPixels.toLocaleString()} pixels)`;
            
            // Update legend for current mode
            updateLegendForMode();
            
            // Show results
            canvas.style.display = 'block';
            document.getElementById('loadingContainer').classList.remove('active');
            document.getElementById('legend').style.display = 'flex';
            document.getElementById('magnifierToggle').style.display = 'block';
            
            // Re-enable process button
            const processBtn = document.getElementById('processBtn');
            processBtn.disabled = false;
            processBtn.textContent = 'Generate Comparison';
        }

        function applyGaussianBlur(imageData, width, height, radius) {
            // Simple box blur approximation (faster than true Gaussian)
            const data = new Uint8ClampedArray(imageData.data);
            const result = new ImageData(width, height);
            
            const kernelSize = radius * 2 + 1;
            const kernelSum = kernelSize * kernelSize;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let r = 0, g = 0, b = 0, a = 0;
                    let count = 0;
                    
                    for (let ky = -radius; ky <= radius; ky++) {
                        for (let kx = -radius; kx <= radius; kx++) {
                            const px = x + kx;
                            const py = y + ky;
                            
                            if (px >= 0 && px < width && py >= 0 && py < height) {
                                const idx = (py * width + px) * 4;
                                r += data[idx];
                                g += data[idx + 1];
                                b += data[idx + 2];
                                a += data[idx + 3];
                                count++;
                            }
                        }
                    }
                    
                    const idx = (y * width + x) * 4;
                    result.data[idx] = Math.floor(r / count);
                    result.data[idx + 1] = Math.floor(g / count);
                    result.data[idx + 2] = Math.floor(b / count);
                    result.data[idx + 3] = Math.floor(a / count);
                }
            }
            
            return result;
        }

        function blockCompare(img1, img2, output, width, height, blockSize, threshold) {
            let diffBlocks = 0;
            
            for (let by = 0; by < height; by += blockSize) {
                for (let bx = 0; bx < width; bx += blockSize) {
                    // Calculate average color for this block in both images
                    let r1_sum = 0, g1_sum = 0, b1_sum = 0;
                    let r2_sum = 0, g2_sum = 0, b2_sum = 0;
                    let pixelCount = 0;
                    
                    for (let y = by; y < Math.min(by + blockSize, height); y++) {
                        for (let x = bx; x < Math.min(bx + blockSize, width); x++) {
                            const pos = (y * width + x) * 4;
                            
                            r1_sum += img1[pos];
                            g1_sum += img1[pos + 1];
                            b1_sum += img1[pos + 2];
                            
                            r2_sum += img2[pos];
                            g2_sum += img2[pos + 1];
                            b2_sum += img2[pos + 2];
                            
                            pixelCount++;
                        }
                    }
                    
                    // Calculate average colors
                    const r1 = r1_sum / pixelCount;
                    const g1 = g1_sum / pixelCount;
                    const b1 = b1_sum / pixelCount;
                    
                    const r2 = r2_sum / pixelCount;
                    const g2 = g2_sum / pixelCount;
                    const b2 = b2_sum / pixelCount;
                    
                    // Calculate block difference
                    const yDiff = rgbToY(r1, g1, b1) - rgbToY(r2, g2, b2);
                    const iDiff = rgbToI(r1, g1, b1) - rgbToI(r2, g2, b2);
                    const qDiff = rgbToQ(r1, g1, b1) - rgbToQ(r2, g2, b2);
                    
                    const delta = Math.sqrt(yDiff * yDiff + iDiff * iDiff + qDiff * qDiff);
                    
                    const isDifferent = delta > threshold;
                    
                    // Mark all pixels in this block with magnitude
                    const magnitude = isDifferent ? Math.min(255, Math.floor((delta / threshold) * 255)) : 0;
                    for (let y = by; y < Math.min(by + blockSize, height); y++) {
                        for (let x = bx; x < Math.min(bx + blockSize, width); x++) {
                            const idx = y * width + x;
                            output[idx] = magnitude;
                        }
                    }
                    
                    if (isDifferent) {
                        diffBlocks += pixelCount;
                    }
                }
            }
            
            return diffBlocks;
        }

        function applyMorphology(diff, width, height, minSize) {
            // Simple morphological closing to group nearby changed pixels
            const result = new Uint8Array(diff);
            const kernel = 3; // 3x3 kernel
            const offset = Math.floor(kernel / 2);

            // Dilation
            const dilated = new Uint8Array(diff.length);
            for (let y = offset; y < height - offset; y++) {
                for (let x = offset; x < width - offset; x++) {
                    let maxVal = 0;
                    for (let ky = -offset; ky <= offset; ky++) {
                        for (let kx = -offset; kx <= offset; kx++) {
                            const idx = (y + ky) * width + (x + kx);
                            maxVal = Math.max(maxVal, diff[idx]);
                        }
                    }
                    dilated[y * width + x] = maxVal;
                }
            }

            // Filter out small regions
            const labeled = labelRegions(dilated, width, height);
            const regionSizes = new Map();
            
            labeled.forEach(label => {
                if (label > 0) {
                    regionSizes.set(label, (regionSizes.get(label) || 0) + 1);
                }
            });

            // Remove small regions
            for (let i = 0; i < labeled.length; i++) {
                const label = labeled[i];
                if (label > 0 && regionSizes.get(label) < minSize) {
                    result[i] = 0;
                } else if (label > 0) {
                    result[i] = 255;
                }
            }

            return result;
        }

        function labelRegions(data, width, height) {
            // Simple connected components labeling
            const labels = new Uint32Array(data.length);
            let nextLabel = 1;

            for (let i = 0; i < data.length; i++) {
                if (data[i] > 0 && labels[i] === 0) {
                    floodFill(data, labels, width, height, i, nextLabel);
                    nextLabel++;
                }
            }

            return labels;
        }

        function floodFill(data, labels, width, height, start, label) {
            const stack = [start];
            
            while (stack.length > 0) {
                const idx = stack.pop();
                if (labels[idx] !== 0 || data[idx] === 0) continue;
                
                labels[idx] = label;
                const x = idx % width;
                const y = Math.floor(idx / width);

                // Check 4-connected neighbors
                if (x > 0) stack.push(idx - 1);
                if (x < width - 1) stack.push(idx + 1);
                if (y > 0) stack.push(idx - width);
                if (y < height - 1) stack.push(idx + width);
            }
        }

        function drawOutlines(ctx, processed, width, height) {
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 3;

            // Simple edge detection - draw line where diff changes from 0 to non-zero
            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    const idx = y * width + x;
                    if (processed[idx] > 0) {
                        // Check if any neighbor is 0 (edge pixel)
                        const neighbors = [
                            processed[idx - 1],
                            processed[idx + 1],
                            processed[idx - width],
                            processed[idx + width]
                        ];
                        
                        if (neighbors.some(n => n === 0)) {
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(x, y, 1, 1);
                        }
                    }
                }
            }
            
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 107, b: 107 };
        }

        function intensityToHeatColor(intensity) {
            // Blue -> Cyan -> Green -> Yellow -> Red heatmap
            const normalized = intensity / 255;
            
            if (normalized < 0.25) {
                // Blue to Cyan
                const t = normalized / 0.25;
                return { r: 0, g: Math.floor(255 * t), b: 255 };
            } else if (normalized < 0.5) {
                // Cyan to Green
                const t = (normalized - 0.25) / 0.25;
                return { r: 0, g: 255, b: Math.floor(255 * (1 - t)) };
            } else if (normalized < 0.75) {
                // Green to Yellow
                const t = (normalized - 0.5) / 0.25;
                return { r: Math.floor(255 * t), g: 255, b: 0 };
            } else {
                // Yellow to Red
                const t = (normalized - 0.75) / 0.25;
                return { r: 255, g: Math.floor(255 * (1 - t)), b: 0 };
            }
        }

        // ========== NEW FEATURES: Presets, Export, History, Projects, Drag & Drop ==========

        let currentPreset = null;
        let isSimpleMode = false;
        let currentComparisonData = null;

        // Initialize Presets
        function initializePresets() {
            const presetsGrid = document.getElementById('presetsGrid');
            const allPresets = getAllPresets();
            
            presetsGrid.innerHTML = '';
            
            Object.keys(allPresets).forEach(presetId => {
                const preset = allPresets[presetId];
                const btn = document.createElement('button');
                btn.className = 'preset-btn';
                btn.dataset.presetId = presetId;
                btn.innerHTML = `
                    <span class="preset-icon">${preset.icon || '‚≠ê'}</span>
                    <span class="preset-name">${preset.name}</span>
                    <span class="preset-desc">${preset.description}</span>
                `;
                btn.addEventListener('click', () => selectPreset(presetId));
                presetsGrid.appendChild(btn);
            });
        }

        function selectPreset(presetId) {
            currentPreset = presetId;
            applyPreset(presetId);
            
            // Update UI
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-preset-id="${presetId}"]`)?.classList.add('active');
        }

        // Simple/Advanced Mode Toggle
        document.getElementById('simpleModeToggle').addEventListener('click', () => {
            isSimpleMode = !isSimpleMode;
            const toggle = document.getElementById('simpleModeToggle');
            const simpleControls = document.getElementById('simpleControls');
            const advancedControls = document.getElementById('advancedControls');
            
            if (isSimpleMode) {
                toggle.textContent = 'Advanced Mode';
                toggle.classList.add('active');
                simpleControls.classList.add('visible');
                advancedControls.classList.add('hidden');
                
                // Sync simple threshold with main threshold
                const threshold = parseFloat(document.getElementById('threshold').value);
                document.getElementById('simpleThreshold').value = threshold;
                document.getElementById('simpleThresholdValue').textContent = threshold;
            } else {
                toggle.textContent = 'Simple Mode';
                toggle.classList.remove('active');
                simpleControls.classList.remove('visible');
                advancedControls.classList.remove('hidden');
            }
        });

        // Sync simple threshold with main threshold
        document.getElementById('simpleThreshold').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('simpleThresholdValue').textContent = value;
            document.getElementById('threshold').value = value;
            document.getElementById('thresholdValue').textContent = value;
        });

        // Export Functions
        function exportCanvas(format = 'png', quality = 0.9) {
            const canvas = document.getElementById('outputCanvas');
            if (!canvas || !beforeImage || !afterImage) {
                alert('No comparison to export. Please generate a comparison first.');
                return;
            }
            
            const filename = `comparison-${Date.now()}.${format}`;
            canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }, `image/${format}`, quality);
        }

        function exportSideBySide() {
            if (!beforeImage || !afterImage) {
                alert('No images to export. Please upload images first.');
                return;
            }
            
            const canvas = document.getElementById('outputCanvas');
            const comparisonCanvas = document.createElement('canvas');
            const width = Math.max(beforeImage.width, afterImage.width, canvas.width);
            const height = beforeImage.height + afterImage.height + canvas.height + 60; // Add spacing
            
            comparisonCanvas.width = width * 3; // Before | After | Comparison
            comparisonCanvas.height = Math.max(beforeImage.height, afterImage.height, canvas.height) + 40;
            
            const ctx = comparisonCanvas.getContext('2d');
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, comparisonCanvas.width, comparisonCanvas.height);
            
            // Draw Before
            ctx.drawImage(beforeImage, 10, 30, beforeImage.width, beforeImage.height);
            ctx.fillStyle = '#333';
            ctx.font = '16px sans-serif';
            ctx.fillText('Before', 10, 20);
            
            // Draw After
            ctx.drawImage(afterImage, width + 20, 30, afterImage.width, afterImage.height);
            ctx.fillText('After', width + 20, 20);
            
            // Draw Comparison
            ctx.drawImage(canvas, width * 2 + 30, 30, canvas.width, canvas.height);
            ctx.fillText('Comparison', width * 2 + 30, 20);
            
            comparisonCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `side-by-side-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
            });
        }

        function exportPDF() {
            // Simple PDF export using canvas
            if (!beforeImage || !afterImage) {
                alert('No images to export. Please upload images first.');
                return;
            }
            
            const canvas = document.getElementById('outputCanvas');
            const pdfCanvas = document.createElement('canvas');
            pdfCanvas.width = 1200;
            pdfCanvas.height = 1600;
            
            const ctx = pdfCanvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, pdfCanvas.width, pdfCanvas.height);
            
            // Title
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px sans-serif';
            ctx.fillText('Visual Comparison Report', 50, 50);
            
            // Date
            ctx.font = '14px sans-serif';
            ctx.fillText(`Generated: ${new Date().toLocaleString()}`, 50, 80);
            
            // Stats
            if (currentComparisonData) {
                ctx.fillText(`Change: ${currentComparisonData.changePercent}%`, 50, 110);
                ctx.fillText(`Pixels Changed: ${currentComparisonData.numDiffPixels.toLocaleString()}`, 50, 135);
            }
            
            // Images
            const imgWidth = 350;
            const imgHeight = (canvas.height / canvas.width) * imgWidth;
            let yPos = 180;
            
            ctx.fillText('Before', 50, yPos);
            ctx.drawImage(beforeImage, 50, yPos + 10, imgWidth, imgHeight);
            yPos += imgHeight + 50;
            
            ctx.fillText('After', 50, yPos);
            ctx.drawImage(afterImage, 50, yPos + 10, imgWidth, imgHeight);
            yPos += imgHeight + 50;
            
            ctx.fillText('Comparison', 50, yPos);
            ctx.drawImage(canvas, 50, yPos + 10, imgWidth, imgHeight);
            
            // Export as image (browser can't generate PDF directly, so we export as PNG)
            pdfCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `comparison-report-${Date.now()}.png`;
                a.click();
                URL.revokeObjectURL(url);
                alert('PDF export saved as PNG. You can print this as PDF from your browser.');
            });
        }

        function copyToClipboard() {
            const canvas = document.getElementById('outputCanvas');
            canvas.toBlob((blob) => {
                navigator.clipboard.write([
                    new ClipboardItem({ 'image/png': blob })
                ]).then(() => {
                    alert('Image copied to clipboard!');
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    alert('Failed to copy to clipboard. Please try downloading instead.');
                });
            });
        }

        // Export button handlers
        document.getElementById('exportPNG').addEventListener('click', () => exportCanvas('png'));
        document.getElementById('exportJPEG').addEventListener('click', () => exportCanvas('jpeg', 0.9));
        document.getElementById('exportSideBySide').addEventListener('click', exportSideBySide);
        document.getElementById('exportPDF').addEventListener('click', exportPDF);
        document.getElementById('copyToClipboard').addEventListener('click', copyToClipboard);

        // History Management
        function saveToHistory() {
            if (!beforeImage || !afterImage || !currentComparisonData) return;
            
            try {
                const history = JSON.parse(localStorage.getItem('comparisonHistory') || '[]');
                const entry = {
                    id: Date.now(),
                    timestamp: new Date().toISOString(),
                    beforeImage: beforeImage.src,
                    afterImage: afterImage.src,
                    beforeFileName: beforeImage.fileName || 'before.jpg',
                    afterFileName: afterImage.fileName || 'after.jpg',
                    settings: getCurrentSettings(),
                    changePercent: currentComparisonData.changePercent,
                    numDiffPixels: currentComparisonData.numDiffPixels,
                    projectId: document.getElementById('projectSelect').value || null,
                    thumbnail: document.getElementById('outputCanvas').toDataURL('image/jpeg', 0.5)
                };
                
                history.unshift(entry);
                // Keep only last 50 entries
                if (history.length > 50) {
                    history = history.slice(0, 50);
                }
                
                localStorage.setItem('comparisonHistory', JSON.stringify(history));
                updateHistoryDisplay();
            } catch (e) {
                console.error('Error saving to history:', e);
            }
        }

        function updateHistoryDisplay() {
            const historyList = document.getElementById('historyList');
            try {
                const history = JSON.parse(localStorage.getItem('comparisonHistory') || '[]');
                
                if (history.length === 0) {
                    historyList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No comparison history yet.</p>';
                    return;
                }
                
                historyList.innerHTML = history.map(entry => {
                    const date = new Date(entry.timestamp);
                    return `
                        <div class="history-item" data-id="${entry.id}">
                            <img src="${entry.thumbnail}" class="history-thumbnail" alt="Comparison">
                            <div class="history-info">
                                <strong>${entry.beforeFileName} vs ${entry.afterFileName}</strong><br>
                                ${date.toLocaleString()}<br>
                                Change: ${entry.changePercent}%
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Add click handlers
                historyList.querySelectorAll('.history-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const id = parseInt(item.dataset.id);
                        loadFromHistory(id);
                    });
                });
            } catch (e) {
                console.error('Error loading history:', e);
                historyList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Error loading history.</p>';
            }
        }

        function loadFromHistory(id) {
            try {
                const history = JSON.parse(localStorage.getItem('comparisonHistory') || '[]');
                const entry = history.find(e => e.id === id);
                if (!entry) return;
                
                // Load images
                const beforeImg = new Image();
                const afterImg = new Image();
                
                beforeImg.onload = () => {
                    afterImg.onload = () => {
                        beforeImage = beforeImg;
                        afterImage = afterImg;
                        beforeImage.fileName = entry.beforeFileName;
                        afterImage.fileName = entry.afterFileName;
                        
                        document.getElementById('beforePreview').src = entry.beforeImage;
                        document.getElementById('beforePreview').style.display = 'block';
                        document.getElementById('beforeBox').classList.add('has-image');
                        
                        document.getElementById('afterPreview').src = entry.afterImage;
                        document.getElementById('afterPreview').style.display = 'block';
                        document.getElementById('afterBox').classList.add('has-image');
                        
                        // Apply settings
                        if (entry.settings) {
                            Object.keys(entry.settings).forEach(key => {
                                const el = document.getElementById(key);
                                if (el) {
                                    if (el.type === 'checkbox') {
                                        el.checked = entry.settings[key];
                                    } else if (el.type === 'range') {
                                        el.value = entry.settings[key];
                                        const valueEl = document.getElementById(key + 'Value');
                                        if (valueEl) {
                                            valueEl.textContent = entry.settings[key];
                                        }
                                    } else {
                                        el.value = entry.settings[key];
                                    }
                                }
                            });
                        }
                        
                        // Set project
                        if (entry.projectId) {
                            document.getElementById('projectSelect').value = entry.projectId;
                        }
                        
                        checkIfReadyToProcess();
                        document.getElementById('historySection').classList.remove('active');
                    };
                    afterImg.src = entry.afterImage;
                };
                beforeImg.src = entry.beforeImage;
            } catch (e) {
                console.error('Error loading from history:', e);
                alert('Error loading comparison from history.');
            }
        }

        // History UI
        document.getElementById('historyToggle').addEventListener('click', () => {
            document.getElementById('historySection').classList.toggle('active');
            updateHistoryDisplay();
        });

        document.getElementById('historyClose').addEventListener('click', () => {
            document.getElementById('historySection').classList.remove('active');
        });

        // Projects Management
        function loadProjects() {
            try {
                const projects = JSON.parse(localStorage.getItem('projects') || '[]');
                const select = document.getElementById('projectSelect');
                select.innerHTML = '<option value="">No Project</option>';
                
                projects.forEach(project => {
                    const option = document.createElement('option');
                    option.value = project.id;
                    option.textContent = project.name;
                    select.appendChild(option);
                });
            } catch (e) {
                console.error('Error loading projects:', e);
            }
        }

        function createProject() {
            const name = prompt('Enter project name:');
            if (!name) return;
            
            try {
                const projects = JSON.parse(localStorage.getItem('projects') || '[]');
                const project = {
                    id: Date.now(),
                    name: name,
                    created: new Date().toISOString()
                };
                projects.push(project);
                localStorage.setItem('projects', JSON.stringify(projects));
                loadProjects();
                document.getElementById('projectSelect').value = project.id;
            } catch (e) {
                console.error('Error creating project:', e);
                alert('Error creating project.');
            }
        }

        document.getElementById('newProjectBtn').addEventListener('click', createProject);
        loadProjects();

        // Drag and Drop
        function setupDragAndDrop() {
            const beforeBox = document.getElementById('beforeBox');
            const afterBox = document.getElementById('afterBox');
            
            [beforeBox, afterBox].forEach((box, index) => {
                const type = index === 0 ? 'before' : 'after';
                
                box.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    box.classList.add('drag-over');
                });
                
                box.addEventListener('dragleave', () => {
                    box.classList.remove('drag-over');
                });
                
                box.addEventListener('drop', (e) => {
                    e.preventDefault();
                    box.classList.remove('drag-over');
                    
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        loadFileAsImage(files[0], type);
                    }
                });
            });
            
            // Also allow dropping on the container for both files
            const container = document.querySelector('.container');
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
            });
            
            container.addEventListener('drop', (e) => {
                e.preventDefault();
                const files = Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('image/'));
                if (files.length >= 2) {
                    loadFileAsImage(files[0], 'before');
                    loadFileAsImage(files[1], 'after');
                } else if (files.length === 1) {
                    // If only one file, ask which side
                    if (!beforeImage) {
                        loadFileAsImage(files[0], 'before');
                    } else if (!afterImage) {
                        loadFileAsImage(files[0], 'after');
                    }
                }
            });
        }

        // Update renderComparisonResult to save data and show export
        const originalRenderComparisonResult = renderComparisonResult;
        renderComparisonResult = function(processed, originalDiff, numDiffPixels) {
            originalRenderComparisonResult(processed, originalDiff, numDiffPixels);
            
            // Store comparison data
            const canvas = document.getElementById('outputCanvas');
            const totalPixels = canvas.width * canvas.height;
            const changePercent = ((numDiffPixels / totalPixels) * 100).toFixed(2);
            
            currentComparisonData = {
                changePercent: changePercent,
                numDiffPixels: numDiffPixels,
                timestamp: new Date().toISOString()
            };
            
            // Show export section
            document.getElementById('exportSection').style.display = 'block';
            
            // Save to history
            saveToHistory();
        };

        // Keyboard Shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    if (beforeImage && afterImage && !document.getElementById('processBtn').disabled) {
                        document.getElementById('processBtn').click();
                    }
                    break;
                case 'e':
                case 'E':
                    if (currentComparisonData) {
                        exportCanvas('png');
                    }
                    break;
                case 'm':
                case 'M':
                    if (document.getElementById('magnifierToggle').style.display !== 'none') {
                        document.getElementById('magnifierToggle').click();
                    }
                    break;
            }
        });

        // Annotation System
        let currentTool = null;
        let isDrawing = false;
        let annotationCanvas = null;
        let annotationCtx = null;
        let startX = 0;
        let startY = 0;

        function initializeAnnotations() {
            annotationCanvas = document.getElementById('annotationCanvas');
            annotationCtx = annotationCanvas.getContext('2d');
            
            // Sync canvas size with output canvas
            const outputCanvas = document.getElementById('outputCanvas');
            const updateAnnotationCanvas = () => {
                if (outputCanvas.width > 0 && outputCanvas.height > 0) {
                    const rect = outputCanvas.getBoundingClientRect();
                    annotationCanvas.width = outputCanvas.width;
                    annotationCanvas.height = outputCanvas.height;
                    annotationCanvas.style.width = rect.width + 'px';
                    annotationCanvas.style.height = rect.height + 'px';
                }
            };
            
            // Update on window resize
            window.addEventListener('resize', updateAnnotationCanvas);
            
            // Update when comparison is rendered
            const originalRender = renderComparisonResult;
            renderComparisonResult = function(...args) {
                originalRender(...args);
                setTimeout(updateAnnotationCanvas, 100);
            };
        }

        function setAnnotationTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.annotation-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const btn = document.querySelector(`[data-tool="${tool}"]`);
            if (btn) btn.classList.add('active');
            
            if (tool) {
                annotationCanvas.classList.add('drawing');
            } else {
                annotationCanvas.classList.remove('drawing');
            }
        }

        function getCanvasCoordinates(e) {
            const canvas = document.getElementById('outputCanvas');
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }

        function setupAnnotationHandlers() {
            const container = document.getElementById('outputContainer');
            
            container.addEventListener('mousedown', (e) => {
                if (!currentTool) return;
                
                const coords = getCanvasCoordinates(e);
                startX = coords.x;
                startY = coords.y;
                isDrawing = true;
                
                if (currentTool === 'text') {
                    const text = prompt('Enter text:');
                    if (text) {
                        annotationCtx.fillStyle = '#ff0000';
                        annotationCtx.font = '20px Arial';
                        annotationCtx.fillText(text, startX, startY);
                    }
                    isDrawing = false;
                }
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentTool) return;
                
                const coords = getCanvasCoordinates(e);
                
                if (currentTool === 'draw') {
                    annotationCtx.strokeStyle = '#ff0000';
                    annotationCtx.lineWidth = 3;
                    annotationCtx.lineCap = 'round';
                    annotationCtx.beginPath();
                    annotationCtx.moveTo(startX, startY);
                    annotationCtx.lineTo(coords.x, coords.y);
                    annotationCtx.stroke();
                    startX = coords.x;
                    startY = coords.y;
                } else if (currentTool === 'highlight') {
                    annotationCtx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    annotationCtx.fillRect(
                        Math.min(startX, coords.x),
                        Math.min(startY, coords.y),
                        Math.abs(coords.x - startX),
                        Math.abs(coords.y - startY)
                    );
                }
            });
            
            container.addEventListener('mouseup', (e) => {
                if (!isDrawing || !currentTool) return;
                
                const coords = getCanvasCoordinates(e);
                
                if (currentTool === 'arrow') {
                    drawArrow(startX, startY, coords.x, coords.y);
                } else if (currentTool === 'highlight') {
                    // Already drawn in mousemove
                }
                
                isDrawing = false;
            });
            
            // Touch support for mobile
            container.addEventListener('touchstart', (e) => {
                if (!currentTool) return;
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousedown', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                container.dispatchEvent(mouseEvent);
            });
            
            container.addEventListener('touchmove', (e) => {
                if (!currentTool || !isDrawing) return;
                e.preventDefault();
                const touch = e.touches[0];
                const mouseEvent = new MouseEvent('mousemove', {
                    clientX: touch.clientX,
                    clientY: touch.clientY
                });
                container.dispatchEvent(mouseEvent);
            });
            
            container.addEventListener('touchend', (e) => {
                if (!currentTool || !isDrawing) return;
                e.preventDefault();
                const mouseEvent = new MouseEvent('mouseup', {});
                container.dispatchEvent(mouseEvent);
            });
        }

        function drawArrow(x1, y1, x2, y2) {
            annotationCtx.strokeStyle = '#ff0000';
            annotationCtx.lineWidth = 3;
            annotationCtx.beginPath();
            annotationCtx.moveTo(x1, y1);
            annotationCtx.lineTo(x2, y2);
            annotationCtx.stroke();
            
            // Draw arrowhead
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 15;
            const arrowAngle = Math.PI / 6;
            
            annotationCtx.beginPath();
            annotationCtx.moveTo(x2, y2);
            annotationCtx.lineTo(
                x2 - arrowLength * Math.cos(angle - arrowAngle),
                y2 - arrowLength * Math.sin(angle - arrowAngle)
            );
            annotationCtx.moveTo(x2, y2);
            annotationCtx.lineTo(
                x2 - arrowLength * Math.cos(angle + arrowAngle),
                y2 - arrowLength * Math.sin(angle + arrowAngle)
            );
            annotationCtx.stroke();
        }

        // Annotation button handlers
        document.getElementById('drawBtn').addEventListener('click', () => setAnnotationTool('draw'));
        document.getElementById('arrowBtn').addEventListener('click', () => setAnnotationTool('arrow'));
        document.getElementById('textBtn').addEventListener('click', () => setAnnotationTool('text'));
        document.getElementById('highlightBtn').addEventListener('click', () => setAnnotationTool('highlight'));
        document.getElementById('clearAnnotationsBtn').addEventListener('click', () => {
            annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
        });
        document.getElementById('toggleAnnotationsBtn').addEventListener('click', () => {
            const tools = document.getElementById('annotationTools');
            tools.classList.toggle('active');
        });

        // Update export functions to include annotations
        const originalExportCanvas = exportCanvas;
        exportCanvas = function(format = 'png', quality = 0.9) {
            const outputCanvas = document.getElementById('outputCanvas');
            if (!outputCanvas || !beforeImage || !afterImage) {
                alert('No comparison to export. Please generate a comparison first.');
                return;
            }
            
            // Create combined canvas with annotations
            const combinedCanvas = document.createElement('canvas');
            combinedCanvas.width = outputCanvas.width;
            combinedCanvas.height = outputCanvas.height;
            const combinedCtx = combinedCanvas.getContext('2d');
            
            // Draw comparison
            combinedCtx.drawImage(outputCanvas, 0, 0);
            
            // Draw annotations
            combinedCtx.drawImage(annotationCanvas, 0, 0);
            
            const filename = `comparison-${Date.now()}.${format}`;
            combinedCanvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                a.click();
                URL.revokeObjectURL(url);
            }, `image/${format}`, quality);
        };

        // Camera integration for mobile
        function setupCameraIntegration() {
            const beforeInput = document.getElementById('beforeInput');
            const afterInput = document.getElementById('afterInput');
            
            // Add capture attribute for mobile cameras
            if (beforeInput) {
                beforeInput.setAttribute('capture', 'environment');
            }
            if (afterInput) {
                afterInput.setAttribute('capture', 'environment');
            }
        }

        // Presentation Mode
        let presentationHistory = [];
        let currentPresentationIndex = -1;

        function enterPresentationMode() {
            if (!currentComparisonData) {
                alert('No comparison to present. Please generate a comparison first.');
                return;
            }
            
            const canvas = document.getElementById('outputCanvas');
            const presentationMode = document.getElementById('presentationMode');
            const presentationImage = document.getElementById('presentationImage');
            const presentationStats = document.getElementById('presentationStats');
            
            // Load history for navigation
            try {
                const history = JSON.parse(localStorage.getItem('comparisonHistory') || '[]');
                presentationHistory = history.filter(h => h.thumbnail);
                currentPresentationIndex = presentationHistory.length - 1;
            } catch (e) {
                console.error('Error loading presentation history:', e);
                presentationHistory = [];
            }
            
            // Show current comparison
            presentationImage.src = canvas.toDataURL('image/png');
            presentationStats.textContent = `Change: ${currentComparisonData.changePercent}% | ${currentComparisonData.numDiffPixels.toLocaleString()} pixels changed`;
            
            presentationMode.classList.add('active');
            document.body.style.overflow = 'hidden';
            
            updatePresentationControls();
        }

        function exitPresentationMode() {
            const presentationMode = document.getElementById('presentationMode');
            presentationMode.classList.remove('active');
            document.body.style.overflow = '';
        }

        function showPresentationItem(index) {
            if (index < 0 || index >= presentationHistory.length) return;
            
            currentPresentationIndex = index;
            const item = presentationHistory[index];
            const presentationImage = document.getElementById('presentationImage');
            const presentationStats = document.getElementById('presentationStats');
            
            presentationImage.src = item.thumbnail;
            presentationStats.textContent = `${item.beforeFileName} vs ${item.afterFileName} | Change: ${item.changePercent}%`;
            
            updatePresentationControls();
        }

        function updatePresentationControls() {
            const prevBtn = document.getElementById('presentationPrev');
            const nextBtn = document.getElementById('presentationNext');
            
            prevBtn.disabled = currentPresentationIndex <= 0;
            nextBtn.disabled = currentPresentationIndex >= presentationHistory.length - 1;
        }

        function presentationNext() {
            if (currentPresentationIndex < presentationHistory.length - 1) {
                showPresentationItem(currentPresentationIndex + 1);
            }
        }

        function presentationPrev() {
            if (currentPresentationIndex > 0) {
                showPresentationItem(currentPresentationIndex - 1);
            }
        }

        // Presentation mode handlers
        document.getElementById('presentationModeBtn').addEventListener('click', enterPresentationMode);
        document.getElementById('presentationClose').addEventListener('click', exitPresentationMode);
        document.getElementById('presentationNext').addEventListener('click', presentationNext);
        document.getElementById('presentationPrev').addEventListener('click', presentationPrev);

        // Keyboard navigation in presentation mode
        document.addEventListener('keydown', (e) => {
            const presentationMode = document.getElementById('presentationMode');
            if (!presentationMode.classList.contains('active')) return;
            
            switch(e.key) {
                case 'Escape':
                    exitPresentationMode();
                    break;
                case 'ArrowRight':
                case ' ':
                    e.preventDefault();
                    presentationNext();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    presentationPrev();
                    break;
            }
        });

        // Initialize all new features
        initializePresets();
        setupDragAndDrop();
        updateHistoryDisplay();
        initializeAnnotations();
        setupAnnotationHandlers();
        setupCameraIntegration();

        // Initialize magnifier
        setupMagnifier();
        
        // Initialize legend for default mode (overlay)
        updateLegendForMode();
    </script>
</body>
</html>
